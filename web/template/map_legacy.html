<style>
    #viewport {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
    }

    #container {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
    }

    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 1.5px;
    }

    path {
        fill:none;
        stroke:silver;
        stroke-width:2;
    }

    rect {
        fill: white;
        stroke: silver;
        width: 70px;
        height: 40px;
        stroke-width: 2;
    }

    text {
        dominant-baseline: middle;
        text-anchor: middle;
    }

    .hide {
        visibility: hidden;
    }

</style>

<h1 style="margin-left: 10px;">Legacy</h1>

<div id="viewport">
    <div id="container">
        <div width="100vw" height="100vh" id="svg-container"></div>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    var svg = d3.select("#svg-container").append("svg")
                .attr("width", "100vw").attr("height", "100vh")
                .append("g").attr("transform", "translate(100,100)");
    
    var data = {{ .afiliasi_list }};

    var dataStructure = d3.stratify()
                            .id(function(d){return d.child;})
                            .parentId(function(d){return d.parent;})
                            (data);
    
    var treeStructure = d3.tree().size([800, 300]);

    var information = treeStructure(dataStructure);
    console.log(information.descendants());

    var connections = svg.append("g").selectAll("path")
                         .data(information.links());
    connections.enter().append("path")
               .attr("d", function (d){
                    return "M" + (d.source.x-100) + "," + (d.source.y) + "h 100 v 100 H" +
                    (d.target.x-100) + " V " + (d.target.y);
                })
               .classed("hide", function(d){
                    if(d.target.data.child == undefined)
                        return true;
                    else
                        return false;
                    });

    var connections2 = svg.append("g").selectAll("path")
                         .data(information.links());
    connections2.enter().append("path")
               .attr("d", function (d){
                if(d.target.data.child == null)
                    return "M" + (d.source.x) + "," + (d.source.y) + "h 10";
                else
                    return "M" + (d.source.x) + "," + (d.source.y) + "h 100";
                });
    
    var rectangles = svg.append("g").selectAll("rect")
                        .data(information.descendants());
    rectangles.enter().append("rect")
              .attr("x", function(d){return d.x-150;})
              .attr("y", function(d){return d.y-30;})
              .classed("hide", function(d){
                if(d.data.child == null)
                    return true;
                else
                    return false;
              });

    var names = svg.append("g").selectAll("text")
                   .data(information.descendants());
    names.enter().append("text")
                 .text(function(d){return d.data.child;})
                 .attr("x", function(d){return d.x;})
                 .attr("y", function(d){return d.y;})
                 .each(wrapText);

    // Function to wrap text within a rectangle
    function wrapText(d) {
        var text = d3.select(this);
        var rectWidth = 80; // Width of the rectangle
        // var x = d.x - rectWidth / 2; // Adjust the x position for left alignment
        var x = d.x - 100; // Adjust the x position for left alignment

        var words = text.text().split(/\s+/).reverse();
        var word;
        var line = [];
        var lineNumber = 0;
        var lineHeight = 1.1; // Adjust this value to set the line height
        var y = text.attr("y");
        var dy = parseFloat(text.attr("dy")) || 0;
        var tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));

            if (tspan.node().getComputedTextLength() > rectWidth) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
        }
    }
     

    var spouseRectangles = svg.append("g").selectAll("rect")
                              .data(information.descendants());
    spouseRectangles.enter().append("rect")
                .attr("x", function(d){return d.x+25;})
                .attr("y", function(d){return d.y-30;})
                .classed("hide", function(d){
                    if(d.data.spouse == undefined)
                        return true;
                    else
                        return false;
                });
    
    var spouseNames = svg.append("g").selectAll("text")
                         .data(information.descendants());
    spouseNames.enter().append("text")
               .text(function(d){return d.data.spouse;})
               .attr("x", function(d){return d.x+100;})
               .attr("y", function(d){return d.y+7;})

    // This part onwards is to handle controls (zoom, drag&drop)
    // Variables to track zoom level and container position
    let zoomLevel = 1;
    let containerX = 0;
    let containerY = 0;
    let isDragging = false;
    let prevX = 0;
    let prevY = 0;

    const viewport = document.getElementById("viewport");

    // Zoom in function
    function zoomIn() {
        zoomLevel += 0.1;
        container.style.transform = `scale(${zoomLevel})`;
        container.classList.add("zoom-out");
    }

    // Zoom out function
    function zoomOut() {
        zoomLevel -= 0.1;
        container.style.transform = `scale(${zoomLevel})`;
        container.classList.add("zoom-in");
    }

    // Reset zoom function
    function resetZoom() {
        zoomLevel = 1;
        container.style.transform = "scale(1)";
        container.classList.remove("zoom-in", "zoom-out");
    }

    // Mouse event handlers
    viewport.addEventListener("mousedown", startDrag);
    viewport.addEventListener("mousemove", dragContainer);
    viewport.addEventListener("mouseup", endDrag);
    viewport.addEventListener("mouseleave", endDrag);

    // Touch event handlers
    viewport.addEventListener("touchstart", startDrag, { passive: false });
    viewport.addEventListener("touchmove", dragContainer, { passive: false });
    viewport.addEventListener("touchend", endDrag);
    viewport.addEventListener("touchcancel", endDrag);

    // Start dragging
    function startDrag(event) {
        event.preventDefault();
        isDragging = true;

        if (event.type === "mousedown") {
            prevX = event.clientX;
            prevY = event.clientY;
        } else if (event.type === "touchstart") {
            prevX = event.touches[0].clientX;
            prevY = event.touches[0].clientY;
        }

        container.style.cursor = "grabbing";
    }

    // Drag container
    function dragContainer(event) {
        if (!isDragging) return;
        event.preventDefault();

        let newX, newY;

        if (event.type === "mousemove") {
            newX = event.clientX;
            newY = event.clientY;
        } else if (event.type === "touchmove") {
            newX = event.touches[0].clientX;
            newY = event.touches[0].clientY;
        }

        const deltaX = newX - prevX;
        const deltaY = newY - prevY;

        containerX += deltaX;
        containerY += deltaY;

        container.style.transform = `scale(${zoomLevel}) translate(${containerX}px, ${containerY}px)`;

        prevX = newX;
        prevY = newY;
    }

    // End dragging
    function endDrag() {
        isDragging = false;
        container.style.cursor = "grab";
    }

    // Double-click to reset zoom
    viewport.addEventListener("dblclick", function (event) {
        resetZoom();
    });

    // Add event listener for wheel event (zoom in/out)
    viewport.addEventListener("wheel", function (event) {
        event.preventDefault();

        if (event.deltaY < 0) {
            zoomIn();
        } else {
            zoomOut();
        }
    });
</script>