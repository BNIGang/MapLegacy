<style>
    #viewport {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
    }

    #container {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
    }

    .node rect {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 2px;
    }

    .node text {
        font: 12px sans-serif;
        text-anchor: middle;
    }

    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 1.5px;
    }

    path {
        fill:none;
        stroke:silver;
        stroke-width:2;
    }

    rect {
        fill: white;
        stroke: silver;
        width: 80px;
        height: 40px;
        stroke-width: 2;
    }

    text {
        text-anchor: middle;
    }

    .hide {
        visibility: hidden;
    }

</style>

<h1 style="margin-left: 10px;">Legacy</h1>

<div id="viewport">
    <div id="container">
        <div width="100vw" height="100vh" id="svg-container"></div>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    var svg = d3.select("#svg-container").append("svg")
                .attr("width", "100vw").attr("height", "100vh")
                .append("g").attr("transform", "translate(50,50)");
    
    var data = {{ .afiliasi_list }};

    var dataStructure = d3.stratify()
                            .id(function(d){return d.child;})
                            .parentId(function(d){return d.parent;})
                            (data);
    
    var treeStructure = d3.tree().size([650, 300]);

    var information = treeStructure(dataStructure);
    console.log(information.descendants());

    var connections = svg.append("g").selectAll("path")
                         .data(information.links());
    connections.enter().append("path")
               .attr("d", function (d){
                    return "M" + (d.source.x-20) + "," + d.source.y + "h 60 v 50 H" +
                    d.target.x + " V" + d.target.y;})
               .classed("hide", function(d){
                    if(d.target.data.child == undefined)
                        return true;
                    else
                        return false;
                    });

    var connections2 = svg.append("g").selectAll("path")
                         .data(information.links());
    connections2.enter().append("path")
               .attr("d", function (d){
                if(d.target.data.child == null)
                    return "M" + (d.source.x) + "," + d.source.y + "h 80";
                else
                    return "M" + (d.source.x+40) + "," + d.source.y + "h 80";
    });
    
    var rectangles = svg.append("g").selectAll("rect")
                        .data(information.descendants());
    rectangles.enter().append("rect")
              .attr("x", function(d){return d.x-60;})
              .attr("y", function(d){return d.y-20;})
              .classed("hide", function(d){
                if(d.data.child == undefined)
                    return true;
                else
                    return false;
              });

    var names = svg.append("g").selectAll("text")
                   .data(information.descendants());
    names.enter().append("text")
                 .text(function(d){return d.data.child;})
                 .attr("x", function(d){return d.x-20;})
                 .attr("y", function(d){return d.y;})

    var spouseRectangles = svg.append("g").selectAll("rect")
                              .data(information.descendants());
    spouseRectangles.enter().append("rect")
                .attr("x", function(d){return d.x+60;})
                .attr("y", function(d){return d.y-20;})
                .classed("hide", function(d){
                    if(d.data.spouse == undefined)
                        return true;
                    else
                        return false;
                });
    
    var spouseNames = svg.append("g").selectAll("text")
                         .data(information.descendants());
    spouseNames.enter().append("text")
               .text(function(d){return d.data.spouse;})
               .attr("x", function(d){return d.x+100;})
               .attr("y", function(d){return d.y;})

    // Variables to track zoom level and container position
    let zoomLevel = 1;
    let containerX = 0;
    let containerY = 0;
    let isDragging = false;
    let prevX = 0;
    let prevY = 0;

    const viewport = document.getElementById("viewport");

    // Zoom in function
    function zoomIn() {
        zoomLevel += 0.1;
        container.style.transform = `scale(${zoomLevel})`;
        container.classList.add("zoom-out");
    }

    // Zoom out function
    function zoomOut() {
        zoomLevel -= 0.1;
        container.style.transform = `scale(${zoomLevel})`;
        container.classList.add("zoom-in");
    }

    // Reset zoom function
    function resetZoom() {
        zoomLevel = 1;
        container.style.transform = "scale(1)";
        container.classList.remove("zoom-in", "zoom-out");
    }

    // Mouse event handlers
    viewport.addEventListener("mousedown", startDrag);
    viewport.addEventListener("mousemove", dragContainer);
    viewport.addEventListener("mouseup", endDrag);
    viewport.addEventListener("mouseleave", endDrag);

    // Touch event handlers
    viewport.addEventListener("touchstart", startDrag, { passive: false });
    viewport.addEventListener("touchmove", dragContainer, { passive: false });
    viewport.addEventListener("touchend", endDrag);
    viewport.addEventListener("touchcancel", endDrag);

    // Start dragging
    function startDrag(event) {
        event.preventDefault();
        isDragging = true;

        if (event.type === "mousedown") {
            prevX = event.clientX;
            prevY = event.clientY;
        } else if (event.type === "touchstart") {
            prevX = event.touches[0].clientX;
            prevY = event.touches[0].clientY;
        }

        container.style.cursor = "grabbing";
    }

    // Drag container
    function dragContainer(event) {
        if (!isDragging) return;
        event.preventDefault();

        let newX, newY;

        if (event.type === "mousemove") {
            newX = event.clientX;
            newY = event.clientY;
        } else if (event.type === "touchmove") {
            newX = event.touches[0].clientX;
            newY = event.touches[0].clientY;
        }

        const deltaX = newX - prevX;
        const deltaY = newY - prevY;

        containerX += deltaX;
        containerY += deltaY;

        container.style.transform = `scale(${zoomLevel}) translate(${containerX}px, ${containerY}px)`;

        prevX = newX;
        prevY = newY;
    }

    // End dragging
    function endDrag() {
        isDragging = false;
        container.style.cursor = "grab";
    }

    // Double-click to reset zoom
    viewport.addEventListener("dblclick", function (event) {
        resetZoom();
    });

    // Add event listener for wheel event (zoom in/out)
    viewport.addEventListener("wheel", function (event) {
        event.preventDefault();

        if (event.deltaY < 0) {
            zoomIn();
        } else {
            zoomOut();
        }
    });
</script>